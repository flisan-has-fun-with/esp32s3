/* automatically generated by rust-bindgen 0.71.1 */

#![allow(unused)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize);
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            byte | mask
        } else {
            byte & !mask
        }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte =
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize);
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if Self::raw_get_bit(this, i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            Self::raw_set_bit(this, index + bit_offset, val_bit_is_set);
        }
    }
}
pub const CONFIG_SOC_MPU_MIN_REGION_SIZE: u32 = 536870912;
pub const CONFIG_SOC_MPU_REGIONS_MAX_NUM: u32 = 8;
pub const CONFIG_SOC_ADC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_UART_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_PCNT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_WIFI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_TWAI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_GDMA_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_AHB_GDMA_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_GPTIMER_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_LCDCAM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MCPWM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_DEDICATED_GPIO_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CACHE_SUPPORT_WRAP: u32 = 1;
pub const CONFIG_SOC_ULP_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ULP_FSM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RISCV_COPROC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_USB_OTG_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_USB_SERIAL_JTAG_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CCOMP_TIMER_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ASYNC_MEMCPY_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SUPPORTS_SECURE_DL_MODE: u32 = 1;
pub const CONFIG_SOC_EFUSE_KEY_PURPOSE_FIELD: u32 = 1;
pub const CONFIG_SOC_EFUSE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SDMMC_HOST_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RTC_FAST_MEM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RTC_SLOW_MEM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RTC_MEM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_PSRAM_DMA_CAPABLE: u32 = 1;
pub const CONFIG_SOC_XT_WDT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SDM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_GPSPI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_LEDC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_I2C_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SYSTIMER_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SUPPORT_COEXISTENCE: u32 = 1;
pub const CONFIG_SOC_TEMP_SENSOR_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_AES_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MPI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_HMAC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_DIG_SIGN_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_FLASH_ENC_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SECURE_BOOT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MEMPROT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_TOUCH_SENSOR_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BOD_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CLK_TREE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MPU_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_WDT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SPI_FLASH_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_XTAL_SUPPORT_40M: u32 = 1;
pub const CONFIG_SOC_APPCPU_HAS_CLOCK_GATING_BUG: u32 = 1;
pub const CONFIG_SOC_ADC_RTC_CTRL_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_DIG_CTRL_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_ARBITER_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_DIG_IIR_FILTER_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_MONITOR_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_DMA_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_PERIPH_NUM: u32 = 2;
pub const CONFIG_SOC_ADC_MAX_CHANNEL_NUM: u32 = 10;
pub const CONFIG_SOC_ADC_ATTEN_NUM: u32 = 4;
pub const CONFIG_SOC_ADC_DIGI_CONTROLLER_NUM: u32 = 2;
pub const CONFIG_SOC_ADC_PATT_LEN_MAX: u32 = 24;
pub const CONFIG_SOC_ADC_DIGI_MIN_BITWIDTH: u32 = 12;
pub const CONFIG_SOC_ADC_DIGI_MAX_BITWIDTH: u32 = 12;
pub const CONFIG_SOC_ADC_DIGI_RESULT_BYTES: u32 = 4;
pub const CONFIG_SOC_ADC_DIGI_DATA_BYTES_PER_CONV: u32 = 4;
pub const CONFIG_SOC_ADC_DIGI_IIR_FILTER_NUM: u32 = 2;
pub const CONFIG_SOC_ADC_DIGI_MONITOR_NUM: u32 = 2;
pub const CONFIG_SOC_ADC_SAMPLE_FREQ_THRES_HIGH: u32 = 83333;
pub const CONFIG_SOC_ADC_SAMPLE_FREQ_THRES_LOW: u32 = 611;
pub const CONFIG_SOC_ADC_RTC_MIN_BITWIDTH: u32 = 12;
pub const CONFIG_SOC_ADC_RTC_MAX_BITWIDTH: u32 = 12;
pub const CONFIG_SOC_ADC_CALIBRATION_V1_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_SELF_HW_CALI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ADC_SHARED_POWER: u32 = 1;
pub const CONFIG_SOC_APB_BACKUP_DMA: u32 = 1;
pub const CONFIG_SOC_BROWNOUT_RESET_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CACHE_WRITEBACK_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CACHE_FREEZE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_CPU_CORES_NUM: u32 = 2;
pub const CONFIG_SOC_CPU_INTR_NUM: u32 = 32;
pub const CONFIG_SOC_CPU_HAS_FPU: u32 = 1;
pub const CONFIG_SOC_HP_CPU_HAS_MULTIPLE_CORES: u32 = 1;
pub const CONFIG_SOC_CPU_BREAKPOINTS_NUM: u32 = 2;
pub const CONFIG_SOC_CPU_WATCHPOINTS_NUM: u32 = 2;
pub const CONFIG_SOC_CPU_WATCHPOINT_MAX_REGION_SIZE: u32 = 64;
pub const CONFIG_SOC_DS_SIGNATURE_MAX_BIT_LEN: u32 = 4096;
pub const CONFIG_SOC_DS_KEY_PARAM_MD_IV_LENGTH: u32 = 16;
pub const CONFIG_SOC_DS_KEY_CHECK_MAX_WAIT_US: u32 = 1100;
pub const CONFIG_SOC_AHB_GDMA_VERSION: u32 = 1;
pub const CONFIG_SOC_GDMA_NUM_GROUPS_MAX: u32 = 1;
pub const CONFIG_SOC_GDMA_PAIRS_PER_GROUP: u32 = 5;
pub const CONFIG_SOC_GDMA_PAIRS_PER_GROUP_MAX: u32 = 5;
pub const CONFIG_SOC_AHB_GDMA_SUPPORT_PSRAM: u32 = 1;
pub const CONFIG_SOC_GPIO_PORT: u32 = 1;
pub const CONFIG_SOC_GPIO_PIN_COUNT: u32 = 49;
pub const CONFIG_SOC_GPIO_SUPPORT_PIN_GLITCH_FILTER: u32 = 1;
pub const CONFIG_SOC_GPIO_FILTER_CLK_SUPPORT_APB: u32 = 1;
pub const CONFIG_SOC_GPIO_SUPPORT_RTC_INDEPENDENT: u32 = 1;
pub const CONFIG_SOC_GPIO_SUPPORT_FORCE_HOLD: u32 = 1;
pub const CONFIG_SOC_GPIO_VALID_GPIO_MASK: u64 = 562949953421311;
pub const CONFIG_SOC_GPIO_IN_RANGE_MAX: u32 = 48;
pub const CONFIG_SOC_GPIO_OUT_RANGE_MAX: u32 = 48;
pub const CONFIG_SOC_GPIO_VALID_DIGITAL_IO_PAD_MASK: u64 = 562949886312448;
pub const CONFIG_SOC_GPIO_CLOCKOUT_BY_IO_MUX: u32 = 1;
pub const CONFIG_SOC_DEDIC_GPIO_OUT_CHANNELS_NUM: u32 = 8;
pub const CONFIG_SOC_DEDIC_GPIO_IN_CHANNELS_NUM: u32 = 8;
pub const CONFIG_SOC_DEDIC_GPIO_OUT_AUTO_ENABLE: u32 = 1;
pub const CONFIG_SOC_I2C_NUM: u32 = 2;
pub const CONFIG_SOC_I2C_FIFO_LEN: u32 = 32;
pub const CONFIG_SOC_I2C_CMD_REG_NUM: u32 = 8;
pub const CONFIG_SOC_I2C_SUPPORT_SLAVE: u32 = 1;
pub const CONFIG_SOC_I2C_SUPPORT_HW_CLR_BUS: u32 = 1;
pub const CONFIG_SOC_I2C_SUPPORT_XTAL: u32 = 1;
pub const CONFIG_SOC_I2C_SUPPORT_RTC: u32 = 1;
pub const CONFIG_SOC_I2C_SUPPORT_10BIT_ADDR: u32 = 1;
pub const CONFIG_SOC_I2C_SLAVE_SUPPORT_BROADCAST: u32 = 1;
pub const CONFIG_SOC_I2C_SLAVE_SUPPORT_I2CRAM_ACCESS: u32 = 1;
pub const CONFIG_SOC_I2S_NUM: u32 = 2;
pub const CONFIG_SOC_I2S_HW_VERSION_2: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_XTAL: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_PLL_F160M: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_PCM: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_PDM: u32 = 1;
pub const CONFIG_SOC_I2S_SUPPORTS_PDM_TX: u32 = 1;
pub const CONFIG_SOC_I2S_PDM_MAX_TX_LINES: u32 = 2;
pub const CONFIG_SOC_I2S_SUPPORTS_PDM_RX: u32 = 1;
pub const CONFIG_SOC_I2S_PDM_MAX_RX_LINES: u32 = 4;
pub const CONFIG_SOC_I2S_SUPPORTS_TDM: u32 = 1;
pub const CONFIG_SOC_LEDC_SUPPORT_APB_CLOCK: u32 = 1;
pub const CONFIG_SOC_LEDC_SUPPORT_XTAL_CLOCK: u32 = 1;
pub const CONFIG_SOC_LEDC_CHANNEL_NUM: u32 = 8;
pub const CONFIG_SOC_LEDC_TIMER_BIT_WIDTH: u32 = 14;
pub const CONFIG_SOC_LEDC_SUPPORT_FADE_STOP: u32 = 1;
pub const CONFIG_SOC_MCPWM_GROUPS: u32 = 2;
pub const CONFIG_SOC_MCPWM_TIMERS_PER_GROUP: u32 = 3;
pub const CONFIG_SOC_MCPWM_OPERATORS_PER_GROUP: u32 = 3;
pub const CONFIG_SOC_MCPWM_COMPARATORS_PER_OPERATOR: u32 = 2;
pub const CONFIG_SOC_MCPWM_GENERATORS_PER_OPERATOR: u32 = 2;
pub const CONFIG_SOC_MCPWM_TRIGGERS_PER_OPERATOR: u32 = 2;
pub const CONFIG_SOC_MCPWM_GPIO_FAULTS_PER_GROUP: u32 = 3;
pub const CONFIG_SOC_MCPWM_CAPTURE_TIMERS_PER_GROUP: u32 = 1;
pub const CONFIG_SOC_MCPWM_CAPTURE_CHANNELS_PER_TIMER: u32 = 3;
pub const CONFIG_SOC_MCPWM_GPIO_SYNCHROS_PER_GROUP: u32 = 3;
pub const CONFIG_SOC_MCPWM_SWSYNC_CAN_PROPAGATE: u32 = 1;
pub const CONFIG_SOC_MMU_LINEAR_ADDRESS_REGION_NUM: u32 = 1;
pub const CONFIG_SOC_MMU_PERIPH_NUM: u32 = 1;
pub const CONFIG_SOC_PCNT_GROUPS: u32 = 1;
pub const CONFIG_SOC_PCNT_UNITS_PER_GROUP: u32 = 4;
pub const CONFIG_SOC_PCNT_CHANNELS_PER_UNIT: u32 = 2;
pub const CONFIG_SOC_PCNT_THRES_POINT_PER_UNIT: u32 = 2;
pub const CONFIG_SOC_RMT_GROUPS: u32 = 1;
pub const CONFIG_SOC_RMT_TX_CANDIDATES_PER_GROUP: u32 = 4;
pub const CONFIG_SOC_RMT_RX_CANDIDATES_PER_GROUP: u32 = 4;
pub const CONFIG_SOC_RMT_CHANNELS_PER_GROUP: u32 = 8;
pub const CONFIG_SOC_RMT_MEM_WORDS_PER_CHANNEL: u32 = 48;
pub const CONFIG_SOC_RMT_SUPPORT_RX_PINGPONG: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_RX_DEMODULATION: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_TX_ASYNC_STOP: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_TX_LOOP_COUNT: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_TX_LOOP_AUTO_STOP: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_TX_SYNCHRO: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_TX_CARRIER_DATA_ONLY: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_XTAL: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_RC_FAST: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_APB: u32 = 1;
pub const CONFIG_SOC_RMT_SUPPORT_DMA: u32 = 1;
pub const CONFIG_SOC_LCD_I80_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_LCD_RGB_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_LCD_I80_BUSES: u32 = 1;
pub const CONFIG_SOC_LCD_RGB_PANELS: u32 = 1;
pub const CONFIG_SOC_LCD_I80_BUS_WIDTH: u32 = 16;
pub const CONFIG_SOC_LCD_RGB_DATA_WIDTH: u32 = 16;
pub const CONFIG_SOC_LCD_SUPPORT_RGB_YUV_CONV: u32 = 1;
pub const CONFIG_SOC_RTC_CNTL_CPU_PD_DMA_BUS_WIDTH: u32 = 128;
pub const CONFIG_SOC_RTC_CNTL_CPU_PD_REG_FILE_NUM: u32 = 549;
pub const CONFIG_SOC_RTC_CNTL_TAGMEM_PD_DMA_BUS_WIDTH: u32 = 128;
pub const CONFIG_SOC_RTCIO_PIN_COUNT: u32 = 22;
pub const CONFIG_SOC_RTCIO_INPUT_OUTPUT_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RTCIO_HOLD_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RTCIO_WAKE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SDM_GROUPS: u32 = 1;
pub const CONFIG_SOC_SDM_CHANNELS_PER_GROUP: u32 = 8;
pub const CONFIG_SOC_SDM_CLK_SUPPORT_APB: u32 = 1;
pub const CONFIG_SOC_SPI_PERIPH_NUM: u32 = 3;
pub const CONFIG_SOC_SPI_MAX_CS_NUM: u32 = 6;
pub const CONFIG_SOC_SPI_MAXIMUM_BUFFER_SIZE: u32 = 64;
pub const CONFIG_SOC_SPI_SUPPORT_DDRCLK: u32 = 1;
pub const CONFIG_SOC_SPI_SLAVE_SUPPORT_SEG_TRANS: u32 = 1;
pub const CONFIG_SOC_SPI_SUPPORT_CD_SIG: u32 = 1;
pub const CONFIG_SOC_SPI_SUPPORT_CONTINUOUS_TRANS: u32 = 1;
pub const CONFIG_SOC_SPI_SUPPORT_SLAVE_HD_VER2: u32 = 1;
pub const CONFIG_SOC_SPI_SUPPORT_CLK_APB: u32 = 1;
pub const CONFIG_SOC_SPI_SUPPORT_CLK_XTAL: u32 = 1;
pub const CONFIG_SOC_SPI_PERIPH_SUPPORT_CONTROL_DUMMY_OUT: u32 = 1;
pub const CONFIG_SOC_MEMSPI_IS_INDEPENDENT: u32 = 1;
pub const CONFIG_SOC_SPI_MAX_PRE_DIVIDER: u32 = 16;
pub const CONFIG_SOC_SPI_SUPPORT_OCT: u32 = 1;
pub const CONFIG_SOC_MEMSPI_SRC_FREQ_120M: u32 = 1;
pub const CONFIG_SOC_MEMSPI_SRC_FREQ_80M_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MEMSPI_SRC_FREQ_40M_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_MEMSPI_SRC_FREQ_20M_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SPIRAM_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SPIRAM_XIP_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_SYSTIMER_COUNTER_NUM: u32 = 2;
pub const CONFIG_SOC_SYSTIMER_ALARM_NUM: u32 = 3;
pub const CONFIG_SOC_SYSTIMER_BIT_WIDTH_LO: u32 = 32;
pub const CONFIG_SOC_SYSTIMER_BIT_WIDTH_HI: u32 = 20;
pub const CONFIG_SOC_SYSTIMER_FIXED_DIVIDER: u32 = 1;
pub const CONFIG_SOC_SYSTIMER_INT_LEVEL: u32 = 1;
pub const CONFIG_SOC_SYSTIMER_ALARM_MISS_COMPENSATE: u32 = 1;
pub const CONFIG_SOC_TIMER_GROUPS: u32 = 2;
pub const CONFIG_SOC_TIMER_GROUP_TIMERS_PER_GROUP: u32 = 2;
pub const CONFIG_SOC_TIMER_GROUP_COUNTER_BIT_WIDTH: u32 = 54;
pub const CONFIG_SOC_TIMER_GROUP_SUPPORT_XTAL: u32 = 1;
pub const CONFIG_SOC_TIMER_GROUP_SUPPORT_APB: u32 = 1;
pub const CONFIG_SOC_TIMER_GROUP_TOTAL_TIMERS: u32 = 4;
pub const CONFIG_SOC_TOUCH_VERSION_2: u32 = 1;
pub const CONFIG_SOC_TOUCH_SENSOR_NUM: u32 = 15;
pub const CONFIG_SOC_TOUCH_PROXIMITY_CHANNEL_NUM: u32 = 3;
pub const CONFIG_SOC_TOUCH_PROXIMITY_MEAS_DONE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_TOUCH_PAD_THRESHOLD_MAX: u32 = 2097151;
pub const CONFIG_SOC_TOUCH_PAD_MEASURE_WAIT_MAX: u32 = 255;
pub const CONFIG_SOC_TWAI_CONTROLLER_NUM: u32 = 1;
pub const CONFIG_SOC_TWAI_CLK_SUPPORT_APB: u32 = 1;
pub const CONFIG_SOC_TWAI_BRP_MIN: u32 = 2;
pub const CONFIG_SOC_TWAI_BRP_MAX: u32 = 16384;
pub const CONFIG_SOC_TWAI_SUPPORTS_RX_STATUS: u32 = 1;
pub const CONFIG_SOC_UART_NUM: u32 = 3;
pub const CONFIG_SOC_UART_HP_NUM: u32 = 3;
pub const CONFIG_SOC_UART_FIFO_LEN: u32 = 128;
pub const CONFIG_SOC_UART_BITRATE_MAX: u32 = 5000000;
pub const CONFIG_SOC_UART_SUPPORT_FSM_TX_WAIT_SEND: u32 = 1;
pub const CONFIG_SOC_UART_SUPPORT_WAKEUP_INT: u32 = 1;
pub const CONFIG_SOC_UART_SUPPORT_APB_CLK: u32 = 1;
pub const CONFIG_SOC_UART_SUPPORT_RTC_CLK: u32 = 1;
pub const CONFIG_SOC_UART_SUPPORT_XTAL_CLK: u32 = 1;
pub const CONFIG_SOC_USB_OTG_PERIPH_NUM: u32 = 1;
pub const CONFIG_SOC_SHA_DMA_MAX_BUFFER_SIZE: u32 = 3968;
pub const CONFIG_SOC_SHA_SUPPORT_DMA: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_RESUME: u32 = 1;
pub const CONFIG_SOC_SHA_GDMA: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA1: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA224: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA256: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA384: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA512: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA512_224: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA512_256: u32 = 1;
pub const CONFIG_SOC_SHA_SUPPORT_SHA512_T: u32 = 1;
pub const CONFIG_SOC_MPI_MEM_BLOCKS_NUM: u32 = 4;
pub const CONFIG_SOC_MPI_OPERATIONS_NUM: u32 = 3;
pub const CONFIG_SOC_RSA_MAX_BIT_LEN: u32 = 4096;
pub const CONFIG_SOC_AES_SUPPORT_DMA: u32 = 1;
pub const CONFIG_SOC_AES_GDMA: u32 = 1;
pub const CONFIG_SOC_AES_SUPPORT_AES_128: u32 = 1;
pub const CONFIG_SOC_AES_SUPPORT_AES_256: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_EXT0_WAKEUP: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_EXT1_WAKEUP: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_EXT_WAKEUP: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_WIFI_WAKEUP: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_BT_WAKEUP: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_TOUCH_SENSOR_WAKEUP: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_CPU_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_TAGMEM_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_RTC_PERIPH_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_RC_FAST_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_VDDSDIO_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_MAC_BB_PD: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_MODEM_PD: u32 = 1;
pub const CONFIG_SOC_CONFIGURABLE_VDDSDIO_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_PM_SUPPORT_DEEPSLEEP_CHECK_STUB_ONLY: u32 = 1;
pub const CONFIG_SOC_PM_CPU_RETENTION_BY_RTCCNTL: u32 = 1;
pub const CONFIG_SOC_PM_MODEM_RETENTION_BY_BACKUPDMA: u32 = 1;
pub const CONFIG_SOC_CLK_RC_FAST_D256_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_RTC_SLOW_CLK_SUPPORT_RC_FAST_D256: u32 = 1;
pub const CONFIG_SOC_CLK_RC_FAST_SUPPORT_CALIBRATION: u32 = 1;
pub const CONFIG_SOC_CLK_XTAL32K_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_EFUSE_DIS_DOWNLOAD_ICACHE: u32 = 1;
pub const CONFIG_SOC_EFUSE_DIS_DOWNLOAD_DCACHE: u32 = 1;
pub const CONFIG_SOC_EFUSE_HARD_DIS_JTAG: u32 = 1;
pub const CONFIG_SOC_EFUSE_DIS_USB_JTAG: u32 = 1;
pub const CONFIG_SOC_EFUSE_SOFT_DIS_JTAG: u32 = 1;
pub const CONFIG_SOC_EFUSE_DIS_DIRECT_BOOT: u32 = 1;
pub const CONFIG_SOC_EFUSE_DIS_ICACHE: u32 = 1;
pub const CONFIG_SOC_EFUSE_BLOCK9_KEY_PURPOSE_QUIRK: u32 = 1;
pub const CONFIG_SOC_SECURE_BOOT_V2_RSA: u32 = 1;
pub const CONFIG_SOC_EFUSE_SECURE_BOOT_KEY_DIGESTS: u32 = 3;
pub const CONFIG_SOC_EFUSE_REVOKE_BOOT_KEY_DIGESTS: u32 = 1;
pub const CONFIG_SOC_SUPPORT_SECURE_BOOT_REVOKE_KEY: u32 = 1;
pub const CONFIG_SOC_FLASH_ENCRYPTED_XTS_AES_BLOCK_MAX: u32 = 64;
pub const CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES: u32 = 1;
pub const CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES_OPTIONS: u32 = 1;
pub const CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES_128: u32 = 1;
pub const CONFIG_SOC_FLASH_ENCRYPTION_XTS_AES_256: u32 = 1;
pub const CONFIG_SOC_MEMPROT_CPU_PREFETCH_PAD_SIZE: u32 = 16;
pub const CONFIG_SOC_MEMPROT_MEM_ALIGN_SIZE: u32 = 256;
pub const CONFIG_SOC_PHY_DIG_REGS_MEM_SIZE: u32 = 21;
pub const CONFIG_SOC_MAC_BB_PD_MEM_SIZE: u32 = 192;
pub const CONFIG_SOC_WIFI_LIGHT_SLEEP_CLK_WIDTH: u32 = 12;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_WAIT_IDLE: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_SUSPEND: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_AUTO_RESUME: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_SW_SUSPEND: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_OPI_MODE: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_TIMING_TUNING: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_CONFIG_GPIO_BY_EFUSE: u32 = 1;
pub const CONFIG_SOC_SPI_MEM_SUPPORT_WRAP: u32 = 1;
pub const CONFIG_SOC_MEMSPI_TIMING_TUNING_BY_MSPI_DELAY: u32 = 1;
pub const CONFIG_SOC_MEMSPI_CORE_CLK_SHARED_WITH_PSRAM: u32 = 1;
pub const CONFIG_SOC_COEX_HW_PTI: u32 = 1;
pub const CONFIG_SOC_EXTERNAL_COEX_LEADER_TX_LINE: u32 = 1;
pub const CONFIG_SOC_SDMMC_USE_GPIO_MATRIX: u32 = 1;
pub const CONFIG_SOC_SDMMC_NUM_SLOTS: u32 = 2;
pub const CONFIG_SOC_SDMMC_SUPPORT_XTAL_CLOCK: u32 = 1;
pub const CONFIG_SOC_SDMMC_DELAY_PHASE_NUM: u32 = 4;
pub const CONFIG_SOC_TEMPERATURE_SENSOR_SUPPORT_FAST_RC: u32 = 1;
pub const CONFIG_SOC_WIFI_HW_TSF: u32 = 1;
pub const CONFIG_SOC_WIFI_FTM_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_GCMP_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_WAPI_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_CSI_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_MESH_SUPPORT: u32 = 1;
pub const CONFIG_SOC_WIFI_SUPPORT_VARIABLE_BEACON_WINDOW: u32 = 1;
pub const CONFIG_SOC_WIFI_PHY_NEEDS_USB_WORKAROUND: u32 = 1;
pub const CONFIG_SOC_BLE_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BLE_MESH_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BLE_50_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BLE_DEVICE_PRIVACY_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_BLUFI_SUPPORTED: u32 = 1;
pub const CONFIG_SOC_ULP_HAS_ADC: u32 = 1;
pub const CONFIG_SOC_PHY_COMBO_MODULE: u32 = 1;
pub const CONFIG_IDF_CMAKE: u32 = 1;
pub const CONFIG_IDF_TOOLCHAIN: &[u8; 4] = b"gcc\0";
pub const CONFIG_IDF_TARGET_ARCH_XTENSA: u32 = 1;
pub const CONFIG_IDF_TARGET_ARCH: &[u8; 7] = b"xtensa\0";
pub const CONFIG_IDF_TARGET: &[u8; 8] = b"esp32s3\0";
pub const CONFIG_IDF_INIT_VERSION: &[u8; 6] = b"5.2.2\0";
pub const CONFIG_IDF_TARGET_ESP32S3: u32 = 1;
pub const CONFIG_IDF_FIRMWARE_CHIP_ID: u32 = 9;
pub const CONFIG_APP_BUILD_TYPE_APP_2NDBOOT: u32 = 1;
pub const CONFIG_APP_BUILD_GENERATE_BINARIES: u32 = 1;
pub const CONFIG_APP_BUILD_BOOTLOADER: u32 = 1;
pub const CONFIG_APP_BUILD_USE_FLASH_SECTIONS: u32 = 1;
pub const CONFIG_BOOTLOADER_COMPILE_TIME_DATE: u32 = 1;
pub const CONFIG_BOOTLOADER_PROJECT_VER: u32 = 1;
pub const CONFIG_BOOTLOADER_OFFSET_IN_FLASH: u32 = 0;
pub const CONFIG_BOOTLOADER_COMPILER_OPTIMIZATION_SIZE: u32 = 1;
pub const CONFIG_BOOTLOADER_LOG_LEVEL_INFO: u32 = 1;
pub const CONFIG_BOOTLOADER_LOG_LEVEL: u32 = 3;
pub const CONFIG_BOOTLOADER_FLASH_XMC_SUPPORT: u32 = 1;
pub const CONFIG_BOOTLOADER_VDDSDIO_BOOST_1_9V: u32 = 1;
pub const CONFIG_BOOTLOADER_REGION_PROTECTION_ENABLE: u32 = 1;
pub const CONFIG_BOOTLOADER_WDT_ENABLE: u32 = 1;
pub const CONFIG_BOOTLOADER_WDT_TIME_MS: u32 = 9000;
pub const CONFIG_BOOTLOADER_RESERVE_RTC_SIZE: u32 = 0;
pub const CONFIG_SECURE_BOOT_V2_RSA_SUPPORTED: u32 = 1;
pub const CONFIG_SECURE_BOOT_V2_PREFERRED: u32 = 1;
pub const CONFIG_SECURE_ROM_DL_MODE_ENABLED: u32 = 1;
pub const CONFIG_APP_COMPILE_TIME_DATE: u32 = 1;
pub const CONFIG_APP_RETRIEVE_LEN_ELF_SHA: u32 = 9;
pub const CONFIG_ESP_ROM_HAS_CRC_LE: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_CRC_BE: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_MZ_CRC32: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_JPEG_DECODE: u32 = 1;
pub const CONFIG_ESP_ROM_UART_CLK_IS_XTAL: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_RETARGETABLE_LOCKING: u32 = 1;
pub const CONFIG_ESP_ROM_USB_OTG_NUM: u32 = 3;
pub const CONFIG_ESP_ROM_USB_SERIAL_DEVICE_NUM: u32 = 4;
pub const CONFIG_ESP_ROM_HAS_ERASE_0_REGION_BUG: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_ENCRYPTED_WRITES_USING_LEGACY_DRV: u32 = 1;
pub const CONFIG_ESP_ROM_GET_CLK_FREQ: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_HAL_WDT: u32 = 1;
pub const CONFIG_ESP_ROM_NEEDS_SWSETUP_WORKAROUND: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_LAYOUT_TABLE: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_SPI_FLASH: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_ETS_PRINTF_BUG: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_NEWLIB_NANO_FORMAT: u32 = 1;
pub const CONFIG_ESP_ROM_NEEDS_SET_CACHE_MMU_SIZE: u32 = 1;
pub const CONFIG_ESP_ROM_RAM_APP_NEEDS_MMU_INIT: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_FLASH_COUNT_PAGES_BUG: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_CACHE_SUSPEND_WAITI_BUG: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_CACHE_WRITEBACK_BUG: u32 = 1;
pub const CONFIG_ESP_ROM_HAS_SW_FLOAT: u32 = 1;
pub const CONFIG_BOOT_ROM_LOG_ALWAYS_ON: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASH_MODE_AUTO_DETECT: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHMODE_DIO: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASH_SAMPLE_MODE_STR: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHMODE: &[u8; 4] = b"dio\0";
pub const CONFIG_ESPTOOLPY_FLASHFREQ_80M: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHFREQ_80M_DEFAULT: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHFREQ: &[u8; 4] = b"80m\0";
pub const CONFIG_ESPTOOLPY_FLASHSIZE_2MB: u32 = 1;
pub const CONFIG_ESPTOOLPY_FLASHSIZE: &[u8; 4] = b"2MB\0";
pub const CONFIG_ESPTOOLPY_BEFORE_RESET: u32 = 1;
pub const CONFIG_ESPTOOLPY_BEFORE: &[u8; 14] = b"default_reset\0";
pub const CONFIG_ESPTOOLPY_AFTER_RESET: u32 = 1;
pub const CONFIG_ESPTOOLPY_AFTER: &[u8; 11] = b"hard_reset\0";
pub const CONFIG_ESPTOOLPY_MONITOR_BAUD: u32 = 115200;
pub const CONFIG_PARTITION_TABLE_SINGLE_APP: u32 = 1;
pub const CONFIG_PARTITION_TABLE_CUSTOM_FILENAME: &[u8; 15] = b"partitions.csv\0";
pub const CONFIG_PARTITION_TABLE_FILENAME: &[u8; 25] = b"partitions_singleapp.csv\0";
pub const CONFIG_PARTITION_TABLE_OFFSET: u32 = 32768;
pub const CONFIG_PARTITION_TABLE_MD5: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_SIZE: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_ASSERTIONS_ENABLE: u32 = 1;
pub const CONFIG_COMPILER_FLOAT_LIB_FROM_GCCLIB: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_ASSERTION_LEVEL: u32 = 2;
pub const CONFIG_COMPILER_HIDE_PATHS_MACROS: u32 = 1;
pub const CONFIG_COMPILER_STACK_CHECK_MODE_NONE: u32 = 1;
pub const CONFIG_COMPILER_RT_LIB_GCCLIB: u32 = 1;
pub const CONFIG_COMPILER_RT_LIB_NAME: &[u8; 4] = b"gcc\0";
pub const CONFIG_EFUSE_MAX_BLK_LEN: u32 = 256;
pub const CONFIG_ESP_ERR_TO_NAME_LOOKUP: u32 = 1;
pub const CONFIG_ESP32S3_REV_MIN_0: u32 = 1;
pub const CONFIG_ESP32S3_REV_MIN_FULL: u32 = 0;
pub const CONFIG_ESP_REV_MIN_FULL: u32 = 0;
pub const CONFIG_ESP32S3_REV_MAX_FULL: u32 = 99;
pub const CONFIG_ESP_REV_MAX_FULL: u32 = 99;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_WIFI_STA: u32 = 1;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_WIFI_AP: u32 = 1;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_BT: u32 = 1;
pub const CONFIG_ESP_MAC_ADDR_UNIVERSE_ETH: u32 = 1;
pub const CONFIG_ESP_MAC_UNIVERSAL_MAC_ADDRESSES_FOUR: u32 = 1;
pub const CONFIG_ESP32S3_UNIVERSAL_MAC_ADDRESSES_FOUR: u32 = 1;
pub const CONFIG_ESP32S3_UNIVERSAL_MAC_ADDRESSES: u32 = 4;
pub const CONFIG_ESP_SLEEP_FLASH_LEAKAGE_WORKAROUND: u32 = 1;
pub const CONFIG_ESP_SLEEP_MSPI_NEED_ALL_IO_PU: u32 = 1;
pub const CONFIG_ESP_SLEEP_RTC_BUS_ISO_WORKAROUND: u32 = 1;
pub const CONFIG_ESP_SLEEP_GPIO_RESET_WORKAROUND: u32 = 1;
pub const CONFIG_ESP_SLEEP_WAIT_FLASH_READY_EXTRA_DELAY: u32 = 2000;
pub const CONFIG_ESP_SLEEP_GPIO_ENABLE_INTERNAL_RESISTORS: u32 = 1;
pub const CONFIG_RTC_CLK_SRC_INT_RC: u32 = 1;
pub const CONFIG_RTC_CLK_CAL_CYCLES: u32 = 1024;
pub const CONFIG_PERIPH_CTRL_FUNC_IN_IRAM: u32 = 1;
pub const CONFIG_XTAL_FREQ_40: u32 = 1;
pub const CONFIG_XTAL_FREQ: u32 = 40;
pub const CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ_240: u32 = 1;
pub const CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ: u32 = 240;
pub const CONFIG_ESP32S3_INSTRUCTION_CACHE_16KB: u32 = 1;
pub const CONFIG_ESP32S3_INSTRUCTION_CACHE_SIZE: u32 = 16384;
pub const CONFIG_ESP32S3_INSTRUCTION_CACHE_8WAYS: u32 = 1;
pub const CONFIG_ESP32S3_ICACHE_ASSOCIATED_WAYS: u32 = 8;
pub const CONFIG_ESP32S3_INSTRUCTION_CACHE_LINE_32B: u32 = 1;
pub const CONFIG_ESP32S3_INSTRUCTION_CACHE_LINE_SIZE: u32 = 32;
pub const CONFIG_ESP32S3_DATA_CACHE_32KB: u32 = 1;
pub const CONFIG_ESP32S3_DATA_CACHE_SIZE: u32 = 32768;
pub const CONFIG_ESP32S3_DATA_CACHE_8WAYS: u32 = 1;
pub const CONFIG_ESP32S3_DCACHE_ASSOCIATED_WAYS: u32 = 8;
pub const CONFIG_ESP32S3_DATA_CACHE_LINE_32B: u32 = 1;
pub const CONFIG_ESP32S3_DATA_CACHE_LINE_SIZE: u32 = 32;
pub const CONFIG_ESP32S3_TRACEMEM_RESERVE_DRAM: u32 = 0;
pub const CONFIG_ESP_SYSTEM_PANIC_PRINT_REBOOT: u32 = 1;
pub const CONFIG_ESP_SYSTEM_PANIC_REBOOT_DELAY_SECONDS: u32 = 0;
pub const CONFIG_ESP_SYSTEM_RTC_FAST_MEM_AS_HEAP_DEPCHECK: u32 = 1;
pub const CONFIG_ESP_SYSTEM_ALLOW_RTC_FAST_MEM_AS_HEAP: u32 = 1;
pub const CONFIG_ESP_SYSTEM_MEMPROT_FEATURE: u32 = 1;
pub const CONFIG_ESP_SYSTEM_MEMPROT_FEATURE_LOCK: u32 = 1;
pub const CONFIG_ESP_SYSTEM_EVENT_QUEUE_SIZE: u32 = 32;
pub const CONFIG_ESP_SYSTEM_EVENT_TASK_STACK_SIZE: u32 = 2304;
pub const CONFIG_ESP_MAIN_TASK_STACK_SIZE: u32 = 32768;
pub const CONFIG_ESP_MAIN_TASK_AFFINITY_CPU0: u32 = 1;
pub const CONFIG_ESP_MAIN_TASK_AFFINITY: u32 = 0;
pub const CONFIG_ESP_MINIMAL_SHARED_STACK_SIZE: u32 = 2048;
pub const CONFIG_ESP_CONSOLE_UART_DEFAULT: u32 = 1;
pub const CONFIG_ESP_CONSOLE_SECONDARY_USB_SERIAL_JTAG: u32 = 1;
pub const CONFIG_ESP_CONSOLE_USB_SERIAL_JTAG_ENABLED: u32 = 1;
pub const CONFIG_ESP_CONSOLE_UART: u32 = 1;
pub const CONFIG_ESP_CONSOLE_UART_NUM: u32 = 0;
pub const CONFIG_ESP_CONSOLE_UART_BAUDRATE: u32 = 115200;
pub const CONFIG_ESP_INT_WDT: u32 = 1;
pub const CONFIG_ESP_INT_WDT_TIMEOUT_MS: u32 = 300;
pub const CONFIG_ESP_INT_WDT_CHECK_CPU1: u32 = 1;
pub const CONFIG_ESP_TASK_WDT_EN: u32 = 1;
pub const CONFIG_ESP_TASK_WDT_INIT: u32 = 1;
pub const CONFIG_ESP_TASK_WDT_TIMEOUT_S: u32 = 5;
pub const CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU0: u32 = 1;
pub const CONFIG_ESP_TASK_WDT_CHECK_IDLE_TASK_CPU1: u32 = 1;
pub const CONFIG_ESP_DEBUG_OCDAWARE: u32 = 1;
pub const CONFIG_ESP_SYSTEM_CHECK_INT_LEVEL_4: u32 = 1;
pub const CONFIG_ESP_BROWNOUT_DET: u32 = 1;
pub const CONFIG_ESP_BROWNOUT_DET_LVL_SEL_7: u32 = 1;
pub const CONFIG_ESP_BROWNOUT_DET_LVL: u32 = 7;
pub const CONFIG_ESP_SYSTEM_BROWNOUT_INTR: u32 = 1;
pub const CONFIG_ESP_SYSTEM_BBPLL_RECALIB: u32 = 1;
pub const CONFIG_ESP_IPC_TASK_STACK_SIZE: u32 = 1280;
pub const CONFIG_ESP_IPC_USES_CALLERS_PRIORITY: u32 = 1;
pub const CONFIG_ESP_IPC_ISR_ENABLE: u32 = 1;
pub const CONFIG_FREERTOS_HZ: u32 = 100;
pub const CONFIG_FREERTOS_CHECK_STACKOVERFLOW_CANARY: u32 = 1;
pub const CONFIG_FREERTOS_THREAD_LOCAL_STORAGE_POINTERS: u32 = 1;
pub const CONFIG_FREERTOS_IDLE_TASK_STACKSIZE: u32 = 1536;
pub const CONFIG_FREERTOS_MAX_TASK_NAME_LEN: u32 = 16;
pub const CONFIG_FREERTOS_TIMER_SERVICE_TASK_NAME: &[u8; 8] = b"Tmr Svc\0";
pub const CONFIG_FREERTOS_TIMER_TASK_PRIORITY: u32 = 1;
pub const CONFIG_FREERTOS_TIMER_TASK_STACK_DEPTH: u32 = 2048;
pub const CONFIG_FREERTOS_TIMER_QUEUE_LENGTH: u32 = 10;
pub const CONFIG_FREERTOS_QUEUE_REGISTRY_SIZE: u32 = 0;
pub const CONFIG_FREERTOS_TASK_NOTIFICATION_ARRAY_ENTRIES: u32 = 1;
pub const CONFIG_FREERTOS_TLSP_DELETION_CALLBACKS: u32 = 1;
pub const CONFIG_FREERTOS_CHECK_MUTEX_GIVEN_BY_OWNER: u32 = 1;
pub const CONFIG_FREERTOS_ISR_STACKSIZE: u32 = 1536;
pub const CONFIG_FREERTOS_INTERRUPT_BACKTRACE: u32 = 1;
pub const CONFIG_FREERTOS_TICK_SUPPORT_SYSTIMER: u32 = 1;
pub const CONFIG_FREERTOS_CORETIMER_SYSTIMER_LVL1: u32 = 1;
pub const CONFIG_FREERTOS_SYSTICK_USES_SYSTIMER: u32 = 1;
pub const CONFIG_FREERTOS_PORT: u32 = 1;
pub const CONFIG_FREERTOS_NO_AFFINITY: u32 = 2147483647;
pub const CONFIG_FREERTOS_SUPPORT_STATIC_ALLOCATION: u32 = 1;
pub const CONFIG_FREERTOS_DEBUG_OCDAWARE: u32 = 1;
pub const CONFIG_FREERTOS_ENABLE_TASK_SNAPSHOT: u32 = 1;
pub const CONFIG_FREERTOS_PLACE_SNAPSHOT_FUNS_INTO_FLASH: u32 = 1;
pub const CONFIG_HAL_ASSERTION_EQUALS_SYSTEM: u32 = 1;
pub const CONFIG_HAL_DEFAULT_ASSERTION_LEVEL: u32 = 2;
pub const CONFIG_HAL_WDT_USE_ROM_IMPL: u32 = 1;
pub const CONFIG_LOG_DEFAULT_LEVEL_INFO: u32 = 1;
pub const CONFIG_LOG_DEFAULT_LEVEL: u32 = 3;
pub const CONFIG_LOG_MAXIMUM_EQUALS_DEFAULT: u32 = 1;
pub const CONFIG_LOG_MAXIMUM_LEVEL: u32 = 3;
pub const CONFIG_LOG_COLORS: u32 = 1;
pub const CONFIG_LOG_TIMESTAMP_SOURCE_RTOS: u32 = 1;
pub const CONFIG_NEWLIB_STDOUT_LINE_ENDING_CRLF: u32 = 1;
pub const CONFIG_NEWLIB_STDIN_LINE_ENDING_CR: u32 = 1;
pub const CONFIG_NEWLIB_TIME_SYSCALL_USE_RTC_HRT: u32 = 1;
pub const CONFIG_MMU_PAGE_SIZE_64KB: u32 = 1;
pub const CONFIG_MMU_PAGE_MODE: &[u8; 5] = b"64KB\0";
pub const CONFIG_MMU_PAGE_SIZE: u32 = 65536;
pub const CONFIG_SPI_FLASH_BROWNOUT_RESET_XMC: u32 = 1;
pub const CONFIG_SPI_FLASH_BROWNOUT_RESET: u32 = 1;
pub const CONFIG_SPI_FLASH_HPM_AUTO: u32 = 1;
pub const CONFIG_SPI_FLASH_HPM_ON: u32 = 1;
pub const CONFIG_SPI_FLASH_HPM_DC_AUTO: u32 = 1;
pub const CONFIG_SPI_FLASH_SUSPEND_QVL_SUPPORTED: u32 = 1;
pub const CONFIG_SPI_FLASH_ROM_DRIVER_PATCH: u32 = 1;
pub const CONFIG_SPI_FLASH_DANGEROUS_WRITE_ABORTS: u32 = 1;
pub const CONFIG_SPI_FLASH_YIELD_DURING_ERASE: u32 = 1;
pub const CONFIG_SPI_FLASH_ERASE_YIELD_DURATION_MS: u32 = 20;
pub const CONFIG_SPI_FLASH_ERASE_YIELD_TICKS: u32 = 1;
pub const CONFIG_SPI_FLASH_WRITE_CHUNK_SIZE: u32 = 8192;
pub const CONFIG_SPI_FLASH_VENDOR_XMC_SUPPORTED: u32 = 1;
pub const CONFIG_SPI_FLASH_VENDOR_GD_SUPPORTED: u32 = 1;
pub const CONFIG_SPI_FLASH_VENDOR_ISSI_SUPPORTED: u32 = 1;
pub const CONFIG_SPI_FLASH_VENDOR_MXIC_SUPPORTED: u32 = 1;
pub const CONFIG_SPI_FLASH_VENDOR_WINBOND_SUPPORTED: u32 = 1;
pub const CONFIG_SPI_FLASH_VENDOR_BOYA_SUPPORTED: u32 = 1;
pub const CONFIG_SPI_FLASH_VENDOR_TH_SUPPORTED: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_ISSI_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_MXIC_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_GD_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_WINBOND_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_BOYA_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_TH_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_SUPPORT_MXIC_OPI_CHIP: u32 = 1;
pub const CONFIG_SPI_FLASH_ENABLE_ENCRYPTED_READ_WRITE: u32 = 1;
pub const CONFIG_BROWNOUT_DET: u32 = 1;
pub const CONFIG_BROWNOUT_DET_LVL: u32 = 7;
pub const CONFIG_BROWNOUT_DET_LVL_SEL_7: u32 = 1;
pub const CONFIG_COMPILER_OPTIMIZATION_LEVEL_RELEASE: u32 = 1;
pub const CONFIG_CONSOLE_UART: u32 = 1;
pub const CONFIG_CONSOLE_UART_BAUDRATE: u32 = 115200;
pub const CONFIG_CONSOLE_UART_DEFAULT: u32 = 1;
pub const CONFIG_CONSOLE_UART_NUM: u32 = 0;
pub const CONFIG_ESP32S3_BROWNOUT_DET: u32 = 1;
pub const CONFIG_ESP32S3_BROWNOUT_DET_LVL: u32 = 7;
pub const CONFIG_ESP32S3_BROWNOUT_DET_LVL_SEL_7: u32 = 1;
pub const CONFIG_ESP32S3_DEBUG_OCDAWARE: u32 = 1;
pub const CONFIG_ESP32S3_DEEP_SLEEP_WAKEUP_DELAY: u32 = 2000;
pub const CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: u32 = 1;
pub const CONFIG_ESP32S3_DEFAULT_CPU_FREQ_MHZ: u32 = 240;
pub const CONFIG_ESP32S3_RTC_CLK_CAL_CYCLES: u32 = 1024;
pub const CONFIG_ESP32S3_RTC_CLK_SRC_INT_RC: u32 = 1;
pub const CONFIG_ESP32S3_TIME_SYSCALL_USE_RTC_FRC1: u32 = 1;
pub const CONFIG_ESP32S3_TIME_SYSCALL_USE_RTC_SYSTIMER: u32 = 1;
pub const CONFIG_ESP_SLEEP_DEEP_SLEEP_WAKEUP_DELAY: u32 = 2000;
pub const CONFIG_ESP_TASK_WDT: u32 = 1;
pub const CONFIG_FLASHMODE_DIO: u32 = 1;
pub const CONFIG_INT_WDT: u32 = 1;
pub const CONFIG_INT_WDT_CHECK_CPU1: u32 = 1;
pub const CONFIG_INT_WDT_TIMEOUT_MS: u32 = 300;
pub const CONFIG_IPC_TASK_STACK_SIZE: u32 = 1280;
pub const CONFIG_LOG_BOOTLOADER_LEVEL: u32 = 3;
pub const CONFIG_LOG_BOOTLOADER_LEVEL_INFO: u32 = 1;
pub const CONFIG_MAIN_TASK_STACK_SIZE: u32 = 32768;
pub const CONFIG_MONITOR_BAUD: u32 = 115200;
pub const CONFIG_OPTIMIZATION_ASSERTIONS_ENABLED: u32 = 1;
pub const CONFIG_OPTIMIZATION_ASSERTION_LEVEL: u32 = 2;
pub const CONFIG_OPTIMIZATION_LEVEL_RELEASE: u32 = 1;
pub const CONFIG_SPI_FLASH_WRITING_DANGEROUS_REGIONS_ABORTS: u32 = 1;
pub const CONFIG_STACK_CHECK_NONE: u32 = 1;
pub const CONFIG_SYSTEM_EVENT_QUEUE_SIZE: u32 = 32;
pub const CONFIG_SYSTEM_EVENT_TASK_STACK_SIZE: u32 = 2304;
pub const CONFIG_TASK_WDT: u32 = 1;
pub const CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU0: u32 = 1;
pub const CONFIG_TASK_WDT_CHECK_IDLE_TASK_CPU1: u32 = 1;
pub const CONFIG_TASK_WDT_TIMEOUT_S: u32 = 5;
pub const CONFIG_TIMER_QUEUE_LENGTH: u32 = 10;
pub const CONFIG_TIMER_TASK_PRIORITY: u32 = 1;
pub const CONFIG_TIMER_TASK_STACK_DEPTH: u32 = 2048;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const BUTTON_1: u32 = 21;
pub const BATT_PIN: u32 = 14;
pub const SD_MISO: u32 = 16;
pub const SD_MOSI: u32 = 15;
pub const SD_SCLK: u32 = 11;
pub const SD_CS: u32 = 42;
pub const BOARD_SCL: u32 = 17;
pub const BOARD_SDA: u32 = 18;
pub const TOUCH_INT: u32 = 47;
pub const GPIO_MISO: u32 = 45;
pub const GPIO_MOSI: u32 = 10;
pub const GPIO_SCLK: u32 = 48;
pub const GPIO_CS: u32 = 39;
pub const EPD_WIDTH: u32 = 960;
pub const EPD_HEIGHT: u32 = 540;
pub type int_least64_t = i64;
pub type uint_least64_t = u64;
pub type int_fast64_t = i64;
pub type uint_fast64_t = u64;
pub type int_least32_t = i32;
pub type uint_least32_t = u32;
pub type int_fast32_t = i32;
pub type uint_fast32_t = u32;
pub type int_least16_t = i16;
pub type uint_least16_t = u16;
pub type int_fast16_t = i16;
pub type uint_fast16_t = u16;
pub type int_least8_t = i8;
pub type uint_least8_t = u8;
pub type int_fast8_t = i8;
pub type uint_fast8_t = u8;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[doc = " @brief An area on the display."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Rect_t {
    pub x: i32,
    #[doc = " Horizontal position."]
    pub y: i32,
    #[doc = " Vertical position."]
    pub width: i32,
    #[doc = " Area / image width, must be positive."]
    pub height: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Rect_t"][::std::mem::size_of::<Rect_t>() - 16usize];
    ["Alignment of Rect_t"][::std::mem::align_of::<Rect_t>() - 4usize];
    ["Offset of field: Rect_t::x"][::std::mem::offset_of!(Rect_t, x) - 0usize];
    ["Offset of field: Rect_t::y"][::std::mem::offset_of!(Rect_t, y) - 4usize];
    ["Offset of field: Rect_t::width"][::std::mem::offset_of!(Rect_t, width) - 8usize];
    ["Offset of field: Rect_t::height"][::std::mem::offset_of!(Rect_t, height) - 12usize];
};
pub const DrawMode_t_BLACK_ON_WHITE: DrawMode_t = 1;
#[doc = " Draw black / grayscale image on a white display."]
pub const DrawMode_t_WHITE_ON_WHITE: DrawMode_t = 2;
#[doc = " \"Draw with white ink\" on a white display."]
pub const DrawMode_t_WHITE_ON_BLACK: DrawMode_t = 4;
#[doc = " @brief The image drawing mode."]
pub type DrawMode_t = ::std::os::raw::c_uint;
pub const DrawFlags_DRAW_BACKGROUND: DrawFlags = 1;
#[doc = " @brief Font drawing flags."]
pub type DrawFlags = ::std::os::raw::c_uint;
#[doc = " @brief Font properties."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FontProperties {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = " Background color"]
    pub fallback_glyph: u32,
    #[doc = " Use the glyph for this codepoint for missing glyphs."]
    pub flags: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FontProperties"][::std::mem::size_of::<FontProperties>() - 12usize];
    ["Alignment of FontProperties"][::std::mem::align_of::<FontProperties>() - 4usize];
    ["Offset of field: FontProperties::fallback_glyph"]
        [::std::mem::offset_of!(FontProperties, fallback_glyph) - 4usize];
    ["Offset of field: FontProperties::flags"]
        [::std::mem::offset_of!(FontProperties, flags) - 8usize];
};
impl FontProperties {
    #[inline]
    pub fn fg_color(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_fg_color(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn fg_color_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_fg_color_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn bg_color(&self) -> u8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_bg_color(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn bg_color_raw(this: *const Self) -> u8 {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 1usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                4usize,
                4u8,
            ) as u8)
        }
    }
    #[inline]
    pub unsafe fn set_bg_color_raw(this: *mut Self, val: u8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 1usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                4usize,
                4u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(fg_color: u8, bg_color: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let fg_color: u8 = unsafe { ::std::mem::transmute(fg_color) };
            fg_color as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let bg_color: u8 = unsafe { ::std::mem::transmute(bg_color) };
            bg_color as u64
        });
        __bindgen_bitfield_unit
    }
}
unsafe extern "C" {
    #[doc = " @brief Initialize the ePaper display"]
    pub fn epd_init();
}
unsafe extern "C" {
    #[doc = " @brief Enable display power supply."]
    pub fn epd_poweron();
}
unsafe extern "C" {
    #[doc = " @brief Disable display power supply."]
    pub fn epd_poweroff();
}
unsafe extern "C" {
    #[doc = " @brief Clear the whole screen by flashing it."]
    pub fn epd_clear();
}
unsafe extern "C" {
    pub fn epd_poweroff_all();
}
unsafe extern "C" {
    #[doc = " @brief Clear an area by flashing it.\n\n @param area The area to clear."]
    pub fn epd_clear_area(area: Rect_t);
}
unsafe extern "C" {
    #[doc = " @brief Clear an area by flashing it.\n\n @param area       The area to clear.\n @param cycles     The number of black-to-white clear cycles.\n @param cycle_time Length of a cycle. Default: 50 (us)."]
    pub fn epd_clear_area_cycles(area: Rect_t, cycles: i32, cycle_time: i32);
}
unsafe extern "C" {
    #[doc = " @brief Darken / lighten an area for a given time.\n\n @param area  The area to darken / lighten.\n @param time  The time in us to apply voltage to each pixel.\n @param color 1: lighten, 0: darken."]
    pub fn epd_push_pixels(area: Rect_t, time: i16, color: i32);
}
unsafe extern "C" {
    #[doc = " @brief Draw a picture to a given area. The image area is not cleared and\n        assumed to be white before drawing.\n\n @param area The display area to draw to. `width` and `height` of the area\n             must correspond to the image dimensions in pixels.\n @param data The image data, as a buffer of 4 bit wide brightness values.\n             Pixel data is packed (two pixels per byte). A byte cannot wrap\n             over multiple rows, images of uneven width must add a padding\n             nibble per line."]
    pub fn epd_draw_grayscale_image(area: Rect_t, data: *mut u8);
}
unsafe extern "C" {
    #[doc = " @brief Draw a picture to a given area, with some draw mode.\n\n @note The image area is not cleared before drawing. For example, this can be\n       used for pixel-aligned clearing.\n\n @param area The display area to draw to. `width` and `height` of the area\n             must correspond to the image dimensions in pixels.\n @param data The image data, as a buffer of 4 bit wide brightness values.\n             Pixel data is packed (two pixels per byte). A byte cannot wrap\n             over multiple rows, images of uneven width must add a padding\n             nibble per line."]
    pub fn epd_draw_image(area: Rect_t, data: *mut u8, mode: DrawMode_t);
}
unsafe extern "C" {
    pub fn epd_draw_frame_1bit(area: Rect_t, ptr: *mut u8, mode: DrawMode_t, time: i32);
}
unsafe extern "C" {
    #[doc = " @brief Rectancle representing the whole screen area."]
    pub fn epd_full_screen() -> Rect_t;
}
unsafe extern "C" {
    #[doc = " @brief Draw a picture to a given framebuffer.\n\n @param image_area  The area to copy to. `width` and `height` of the area must\n                    correspond to the image dimensions in pixels.\n @param image_data  The image data, as a buffer of 4 bit wide brightness values.\n                    Pixel data is packed (two pixels per byte). A byte cannot\n                    wrap over multiple rows, images of uneven width must add a\n                    padding nibble per line.\n @param framebuffer The framebuffer object, which must\n                    be `EPD_WIDTH / 2 * EPD_HEIGHT` large."]
    pub fn epd_copy_to_framebuffer(image_area: Rect_t, image_data: *mut u8, framebuffer: *mut u8);
}
unsafe extern "C" {
    #[doc = " @brief Draw a pixel a given framebuffer.\n\n @param x           Horizontal position in pixels.\n @param y           Vertical position in pixels.\n @param color       The gray value of the line (0-255);\n @param framebuffer The framebuffer to draw to."]
    pub fn epd_draw_pixel(x: i32, y: i32, color: u8, framebuffer: *mut u8);
}
unsafe extern "C" {
    #[doc = " @brief Draw a horizontal line to a given framebuffer.\n\n @param x           Horizontal start position in pixels.\n @param y           Vertical start position in pixels.\n @param length      Length of the line in pixels.\n @param color       The gray value of the line (0-255);\n @param framebuffer The framebuffer to draw to, which must\n                    be `EPD_WIDTH / 2 * EPD_HEIGHT` bytes large."]
    pub fn epd_draw_hline(x: i32, y: i32, length: i32, color: u8, framebuffer: *mut u8);
}
unsafe extern "C" {
    #[doc = " @brief Draw a horizontal line to a given framebuffer.\n\n @param x           Horizontal start position in pixels.\n @param y           Vertical start position in pixels.\n @param length      Length of the line in pixels.\n @param color       The gray value of the line (0-255);\n @param framebuffer The framebuffer to draw to, which must\n                    be `EPD_WIDTH / 2 * EPD_HEIGHT` bytes large."]
    pub fn epd_draw_vline(x: i32, y: i32, length: i32, color: u8, framebuffer: *mut u8);
}
unsafe extern "C" {
    #[doc = " @brief Draw a circle with given center and radius\n\n @param x0          Center-point x coordinate\n @param y0          Center-point y coordinate\n @param r           Radius of the circle in pixels\n @param color       The gray value of the line (0-255);\n @param framebuffer The framebuffer to draw to"]
    pub fn epd_draw_circle(x: i32, y: i32, r: i32, color: u8, framebuffer: *mut u8);
}
unsafe extern "C" {
    #[doc = " @brief Draw a circle with fill with given center and radius\n\n @param x0          Center-point x coordinate\n @param y0          Center-point y coordinate\n @param r           Radius of the circle in pixels\n @param color       The gray value of the line (0-255);\n @param framebuffer The framebuffer to draw to,"]
    pub fn epd_fill_circle(x: i32, y: i32, r: i32, color: u8, framebuffer: *mut u8);
}
unsafe extern "C" {
    #[doc = " @brief Draw a rectanle with no fill color\n\n @param x           Top left corner x coordinate\n @param y           Top left corner y coordinate\n @param w           Width in pixels\n @param h           Height in pixels\n @param color       The gray value of the line (0-255);\n @param framebuffer The framebuffer to draw to,"]
    pub fn epd_draw_rect(x: i32, y: i32, w: i32, h: i32, color: u8, framebuffer: *mut u8);
}
unsafe extern "C" {
    #[doc = " @brief Draw a rectanle with fill color\n\n @param x           Top left corner x coordinate\n @param y           Top left corner y coordinate\n @param w           Width in pixels\n @param h           Height in pixels\n @param color       The gray value of the line (0-255);\n @param framebuffer The framebuffer to draw to"]
    pub fn epd_fill_rect(x: i32, y: i32, w: i32, h: i32, color: u8, framebuffer: *mut u8);
}
unsafe extern "C" {
    #[doc = " @brief Write a line.  Bresenham's algorithm - thx wikpedia\n\n @param x0          Start point x coordinate\n @param y0          Start point y coordinate\n @param x1          End point x coordinate\n @param y1          End point y coordinate\n @param color       The gray value of the line (0-255);\n @param framebuffer The framebuffer to draw to"]
    pub fn epd_write_line(x0: i32, y0: i32, x1: i32, y1: i32, color: u8, framebuffer: *mut u8);
}
unsafe extern "C" {
    #[doc = " @brief Draw a line\n\n @param x0          Start point x coordinate\n @param y0          Start point y coordinate\n @param x1          End point x coordinate\n @param y1          End point y coordinate\n @param color       The gray value of the line (0-255);\n @param framebuffer The framebuffer to draw to"]
    pub fn epd_draw_line(x0: i32, y0: i32, x1: i32, y1: i32, color: u8, framebuffer: *mut u8);
}
unsafe extern "C" {
    #[doc = " @brief Draw a triangle with no fill color\n\n @param x0          Vertex #0 x coordinate\n @param y0          Vertex #0 y coordinate\n @param x1          Vertex #1 x coordinate\n @param y1          Vertex #1 y coordinate\n @param x2          Vertex #2 x coordinate\n @param y2          Vertex #2 y coordinate\n @param color       The gray value of the line (0-255);\n @param framebuffer The framebuffer to draw to"]
    pub fn epd_draw_triangle(
        x0: i32,
        y0: i32,
        x1: i32,
        y1: i32,
        x2: i32,
        y2: i32,
        color: u8,
        framebuffer: *mut u8,
    );
}
unsafe extern "C" {
    #[doc = " @brief Draw a triangle with color-fill\n\n @param x0          Vertex #0 x coordinate\n @param y0          Vertex #0 y coordinate\n @param x1          Vertex #1 x coordinate\n @param y1          Vertex #1 y coordinate\n @param x2          Vertex #2 x coordinate\n @param y2          Vertex #2 y coordinate\n @param color       The gray value of the line (0-255);\n @param framebuffer The framebuffer to draw to"]
    pub fn epd_fill_triangle(
        x0: i32,
        y0: i32,
        x1: i32,
        y1: i32,
        x2: i32,
        y2: i32,
        color: u8,
        framebuffer: *mut u8,
    );
}
#[doc = " @brief Font data stored PER GLYPH"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GFXglyph {
    pub width: u8,
    #[doc = " Bitmap dimensions in pixels"]
    pub height: u8,
    #[doc = " Bitmap dimensions in pixels"]
    pub advance_x: u8,
    #[doc = " Distance to advance cursor (x axis)"]
    pub left: i16,
    #[doc = " X dist from cursor pos to UL corner"]
    pub top: i16,
    #[doc = " Y dist from cursor pos to UL corner"]
    pub compressed_size: u16,
    #[doc = " Size of the zlib-compressed font data."]
    pub data_offset: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GFXglyph"][::std::mem::size_of::<GFXglyph>() - 16usize];
    ["Alignment of GFXglyph"][::std::mem::align_of::<GFXglyph>() - 4usize];
    ["Offset of field: GFXglyph::width"][::std::mem::offset_of!(GFXglyph, width) - 0usize];
    ["Offset of field: GFXglyph::height"][::std::mem::offset_of!(GFXglyph, height) - 1usize];
    ["Offset of field: GFXglyph::advance_x"][::std::mem::offset_of!(GFXglyph, advance_x) - 2usize];
    ["Offset of field: GFXglyph::left"][::std::mem::offset_of!(GFXglyph, left) - 4usize];
    ["Offset of field: GFXglyph::top"][::std::mem::offset_of!(GFXglyph, top) - 6usize];
    ["Offset of field: GFXglyph::compressed_size"]
        [::std::mem::offset_of!(GFXglyph, compressed_size) - 8usize];
    ["Offset of field: GFXglyph::data_offset"]
        [::std::mem::offset_of!(GFXglyph, data_offset) - 12usize];
};
#[doc = " @brief Glyph interval structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UnicodeInterval {
    pub first: u32,
    #[doc = " The first unicode code point of the interval"]
    pub last: u32,
    #[doc = " The last unicode code point of the interval"]
    pub offset: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of UnicodeInterval"][::std::mem::size_of::<UnicodeInterval>() - 12usize];
    ["Alignment of UnicodeInterval"][::std::mem::align_of::<UnicodeInterval>() - 4usize];
    ["Offset of field: UnicodeInterval::first"]
        [::std::mem::offset_of!(UnicodeInterval, first) - 0usize];
    ["Offset of field: UnicodeInterval::last"]
        [::std::mem::offset_of!(UnicodeInterval, last) - 4usize];
    ["Offset of field: UnicodeInterval::offset"]
        [::std::mem::offset_of!(UnicodeInterval, offset) - 8usize];
};
#[doc = " @brief Data stored for FONT AS A WHOLE"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GFXfont {
    pub bitmap: *mut u8,
    #[doc = " Glyph bitmaps, concatenated"]
    pub glyph: *mut GFXglyph,
    #[doc = " Glyph array"]
    pub intervals: *mut UnicodeInterval,
    #[doc = " Valid unicode intervals for this font"]
    pub interval_count: u32,
    #[doc = " Number of unicode intervals."]
    pub compressed: bool,
    #[doc = " Does this font use compressed glyph bitmaps?"]
    pub advance_y: u8,
    #[doc = " Newline distance (y axis)"]
    pub ascender: i32,
    #[doc = " Maximal height of a glyph above the base line"]
    pub descender: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GFXfont"][::std::mem::size_of::<GFXfont>() - 28usize];
    ["Alignment of GFXfont"][::std::mem::align_of::<GFXfont>() - 4usize];
    ["Offset of field: GFXfont::bitmap"][::std::mem::offset_of!(GFXfont, bitmap) - 0usize];
    ["Offset of field: GFXfont::glyph"][::std::mem::offset_of!(GFXfont, glyph) - 4usize];
    ["Offset of field: GFXfont::intervals"][::std::mem::offset_of!(GFXfont, intervals) - 8usize];
    ["Offset of field: GFXfont::interval_count"]
        [::std::mem::offset_of!(GFXfont, interval_count) - 12usize];
    ["Offset of field: GFXfont::compressed"][::std::mem::offset_of!(GFXfont, compressed) - 16usize];
    ["Offset of field: GFXfont::advance_y"][::std::mem::offset_of!(GFXfont, advance_y) - 17usize];
    ["Offset of field: GFXfont::ascender"][::std::mem::offset_of!(GFXfont, ascender) - 20usize];
    ["Offset of field: GFXfont::descender"][::std::mem::offset_of!(GFXfont, descender) - 24usize];
};
unsafe extern "C" {
    #[doc = " @brief Get the text bounds for string, when drawn at (x, y).\n        Set font properties to NULL to use the defaults."]
    pub fn get_text_bounds(
        font: *const GFXfont,
        string: *const ::std::os::raw::c_char,
        x: *mut i32,
        y: *mut i32,
        x1: *mut i32,
        y1: *mut i32,
        w: *mut i32,
        h: *mut i32,
        props: *const FontProperties,
    );
}
unsafe extern "C" {
    #[doc = " @brief Write text to the EPD."]
    pub fn writeln(
        font: *const GFXfont,
        string: *const ::std::os::raw::c_char,
        cursor_x: *mut i32,
        cursor_y: *mut i32,
        framebuffer: *mut u8,
    );
}
unsafe extern "C" {
    #[doc = " @brief Write text to the EPD.\n\n @note If framebuffer is NULL, draw mode `mode` is used for direct drawing."]
    pub fn write_mode(
        font: *const GFXfont,
        string: *const ::std::os::raw::c_char,
        cursor_x: *mut i32,
        cursor_y: *mut i32,
        framebuffer: *mut u8,
        mode: DrawMode_t,
        properties: *const FontProperties,
    );
}
unsafe extern "C" {
    #[doc = " @brief Get the font glyph for a unicode code point."]
    pub fn get_glyph(font: *const GFXfont, code_point: u32, glyph: *mut *mut GFXglyph);
}
unsafe extern "C" {
    #[doc = " @brief Write a (multi-line) string to the EPD."]
    pub fn write_string(
        font: *const GFXfont,
        string: *const ::std::os::raw::c_char,
        cursor_x: *mut i32,
        cursor_y: *mut i32,
        framebuffer: *mut u8,
    );
}
